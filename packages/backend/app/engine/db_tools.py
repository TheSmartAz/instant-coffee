"""DB-backed file tools — subclass agent file tools to persist to the database.

``DBWriteFile`` and ``DBEditFile`` intercept writes to special paths:

- ``PRODUCT.md`` → upsert ``product_docs`` table + create history
- ``*.html``     → create/update ``pages`` + ``page_versions`` tables
- Everything else → filesystem only (delegates to parent)
"""

from __future__ import annotations

import logging
import os
import re
from pathlib import Path
from typing import Any, Optional

from ic.tools.base import ToolResult
from ic.tools.file import WriteFile, EditFile, MultiEditFile, _resolve, _check_sandbox

from ..events.emitter import EventEmitter
from ..events.models import (
    PageCreatedEvent,
    PagePreviewReadyEvent,
    PageVersionCreatedEvent,
    ProductDocGeneratedEvent,
    ProductDocUpdatedEvent,
)

logger = logging.getLogger(__name__)

_SLUG_RE = re.compile(r"^[a-z0-9-]+$")
_PRODUCT_DOC_NAMES = {"product.md", "product-doc.md"}


def _is_product_doc(file_path: str) -> bool:
    return os.path.basename(file_path).lower() in _PRODUCT_DOC_NAMES


def _is_html(file_path: str) -> bool:
    return file_path.lower().endswith(".html")


def _slug_from_filename(file_path: str) -> str:
    """Derive a page slug from a filename like ``landing.html``."""
    name = os.path.basename(file_path)
    stem = os.path.splitext(name)[0]
    slug = re.sub(r"[^a-z0-9-]", "-", stem.lower()).strip("-")
    slug = re.sub(r"-+", "-", slug)
    return slug[:40] or "page"


def _title_from_slug(slug: str) -> str:
    return slug.replace("-", " ").title()


def persist_html_page(
    db_session: Any,
    session_id: str,
    file_path: str,
    content: str,
    emitter: Optional[EventEmitter] = None,
    description: str = "Generated by engine",
) -> None:
    """Persist an HTML file to the pages + page_versions tables.

    This is the single source of truth for HTML→DB persistence, used by
    both ``DBWriteFile``, ``DBEditFile``, and the workspace-sync logic.
    """
    if not db_session or not session_id:
        return
    from ..services.page import PageService
    from ..services.page_version import PageVersionService

    slug = _slug_from_filename(file_path)
    title = _title_from_slug(slug)

    page_svc = PageService(db_session, event_emitter=emitter)
    version_svc = PageVersionService(db_session, event_emitter=emitter)

    page = page_svc.get_by_slug(session_id, slug)
    if page is None:
        pages = page_svc.list_by_session(session_id)
        order = len(pages)
        page = page_svc.create(
            session_id=session_id,
            title=title,
            slug=slug,
            order_index=order,
        )

    version_svc.create_version(page.id, html=content, description=description)
    db_session.commit()


class DBWriteFile(WriteFile):
    """WriteFile that also persists PRODUCT.md and HTML to the database."""

    def __init__(
        self,
        workspace: Path | None = None,
        *,
        db_session: Any = None,
        session_id: str = "",
        emitter: Optional[EventEmitter] = None,
        engine: Any = None,
        deferred_buffer: Any = None,
    ):
        super().__init__(workspace, engine=engine)
        self._db = db_session
        self._session_id = session_id
        self._emitter = emitter
        self._deferred_buffer = deferred_buffer

    async def execute(self, **kwargs: Any) -> ToolResult:
        file_path = kwargs.get("file_path", "")
        content = kwargs.get("content", "")

        # Always write to filesystem first
        result = await super().execute(**kwargs)
        if result.is_error:
            return result

        # Persist to DB (or buffer for deferred flush)
        try:
            if _is_product_doc(file_path):
                self._persist_product_doc(content, file_path)
            elif _is_html(file_path):
                self._persist_html_page(file_path, content)
        except Exception:
            logger.exception("DB persistence failed for %s", file_path)

        return result

    def _persist_product_doc(self, content: str, file_path: str = "") -> None:
        if not self._db or not self._session_id:
            return
        if self._deferred_buffer is not None:
            self._deferred_buffer.record_product_doc(file_path, content)
            return
        from ..services.product_doc import ProductDocService

        svc = ProductDocService(self._db, event_emitter=self._emitter)
        existing = svc.get_by_session_id(self._session_id)

        if existing is None:
            svc.create(
                session_id=self._session_id,
                content=content,
                structured={},
            )
        else:
            svc.update(
                existing.id,
                content=content,
                change_summary="Updated via engine write_file",
            )
        self._db.commit()

    def _persist_html_page(self, file_path: str, content: str) -> None:
        if self._deferred_buffer is not None:
            slug = _slug_from_filename(file_path)
            self._deferred_buffer.record_html(file_path, content, slug)
            return
        persist_html_page(
            self._db, self._session_id, file_path, content,
            emitter=self._emitter, description="Generated by engine",
        )


class DBEditFile(EditFile):
    """EditFile that also updates PRODUCT.md and HTML in the database."""

    def __init__(
        self,
        workspace: Path | None = None,
        *,
        db_session: Any = None,
        session_id: str = "",
        emitter: Optional[EventEmitter] = None,
        engine: Any = None,
        deferred_buffer: Any = None,
    ):
        super().__init__(workspace, engine=engine)
        self._db = db_session
        self._session_id = session_id
        self._emitter = emitter
        self._deferred_buffer = deferred_buffer

    async def execute(self, **kwargs: Any) -> ToolResult:
        file_path = kwargs.get("file_path", "")

        # Execute the edit on filesystem
        result = await super().execute(**kwargs)
        if result.is_error:
            return result

        # Re-read the file and persist to DB (or buffer)
        try:
            resolved = _resolve(file_path, self._workspace)
            if resolved.exists():
                updated_content = resolved.read_text(encoding="utf-8")
                if _is_product_doc(file_path):
                    self._persist_product_doc(updated_content, file_path)
                elif _is_html(file_path):
                    self._persist_html_page(file_path, updated_content)
        except Exception:
            logger.exception("DB persistence failed for edit of %s", file_path)

        return result

    def _persist_product_doc(self, content: str, file_path: str = "") -> None:
        if not self._db or not self._session_id:
            return
        if self._deferred_buffer is not None:
            self._deferred_buffer.record_product_doc(file_path, content)
            return
        from ..services.product_doc import ProductDocService

        svc = ProductDocService(self._db, event_emitter=self._emitter)
        existing = svc.get_by_session_id(self._session_id)

        if existing is None:
            svc.create(
                session_id=self._session_id,
                content=content,
                structured={},
            )
        else:
            svc.update(
                existing.id,
                content=content,
                change_summary="Updated via engine edit_file",
            )
        self._db.commit()

    def _persist_html_page(self, file_path: str, content: str) -> None:
        if self._deferred_buffer is not None:
            slug = _slug_from_filename(file_path)
            self._deferred_buffer.record_html(file_path, content, slug)
            return
        persist_html_page(
            self._db, self._session_id, file_path, content,
            emitter=self._emitter, description="Edited by engine",
        )


class DBMultiEditFile(MultiEditFile):
    """MultiEditFile that also persists PRODUCT.md and HTML to the database."""

    def __init__(
        self,
        workspace: Path | None = None,
        *,
        db_session: Any = None,
        session_id: str = "",
        emitter: Optional[EventEmitter] = None,
        deferred_buffer: Any = None,
    ):
        super().__init__(workspace)
        self._db = db_session
        self._session_id = session_id
        self._emitter = emitter
        self._deferred_buffer = deferred_buffer

    async def execute(self, **kwargs: Any) -> ToolResult:
        file_path = kwargs.get("file_path", "")

        result = await super().execute(**kwargs)
        if result.is_error:
            return result

        # Re-read the file and persist to DB (or buffer)
        try:
            resolved = _resolve(file_path, self._workspace)
            if resolved.exists():
                updated_content = resolved.read_text(encoding="utf-8")
                if _is_product_doc(file_path):
                    self._persist_product_doc(updated_content, file_path)
                elif _is_html(file_path):
                    self._persist_html_page(file_path, updated_content)
        except Exception:
            logger.exception("DB persistence failed for multi_edit of %s", file_path)

        return result

    def _persist_product_doc(self, content: str, file_path: str = "") -> None:
        if not self._db or not self._session_id:
            return
        if self._deferred_buffer is not None:
            self._deferred_buffer.record_product_doc(file_path, content)
            return
        from ..services.product_doc import ProductDocService

        svc = ProductDocService(self._db, event_emitter=self._emitter)
        existing = svc.get_by_session_id(self._session_id)

        if existing is None:
            svc.create(session_id=self._session_id, content=content, structured={})
        else:
            svc.update(existing.id, content=content, change_summary="Updated via engine multi_edit_file")
        self._db.commit()

    def _persist_html_page(self, file_path: str, content: str) -> None:
        if self._deferred_buffer is not None:
            slug = _slug_from_filename(file_path)
            self._deferred_buffer.record_html(file_path, content, slug)
            return
        persist_html_page(
            self._db, self._session_id, file_path, content,
            emitter=self._emitter, description="Multi-edited by engine",
        )

# Instant Coffee - LangGraph v1 设计补充说明 (Spec v0.7.1-01)

**项目名称**: Instant Coffee (速溶咖啡)
**版本**: v0.7.1-01 - LangGraph v1 设计补充
**日期**: 2026-02-05
**文档类型**: Technical Specification Addendum

---

## 文档变更历史

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|---------|------|
| v0.7.1-01 | 2026-02-05 | 基于 LangGraph v1 更新编排设计、持久化、HITL、重试、流式事件与 API 约定 | Planning |

---

## 0. 说明与适用范围

本补充文档建立在 `docs/spec/spec-07.md` 之上，仅覆盖 **“使用最新 LangGraph 版本的系统设计”**。其他业务能力（场景旅程、组件注册表、Mobile Shell、React SSG 等）保持不变。

最新版本确认：根据 docs-langchain 最新文档，LangGraph **最新主版本为 v1**，核心图编排 API 保持稳定，新增/强化稳定性、类型、安全、持久化与 HITL 体验。

---

## 1. 设计目标（对齐 LangGraph v1）

1. **持久化与可恢复优先**：默认使用 checkpointer 保存图状态，支持随时中断/恢复。
2. **Human-in-the-loop 原生化**：使用 `interrupt()` + `Command(resume=...)` 替代“外部标志位轮询”。
3. **流式可观测**：用图执行的 `stream` 输出统一驱动 SSE 事件。
4. **重试与缓存标准化**：用内建 `RetryPolicy` / `CachePolicy` 替代自研重试计数。
5. **线程（thread_id）与会话对齐**：`thread_id = session_id`，统一“会话-图状态”映射。

---

## 2. LangGraph v1 关键能力摘要（用于设计取舍）

- **稳定核心 API**：`StateGraph`/`add_node`/`add_edge`/`compile` 仍是主路径。
- **Durable Execution**：checkpointer 写入状态，出错可恢复。
- **Interrupts**：任意节点内 `interrupt()` 可暂停并等待外部输入。
- **Streaming**：图支持流式输出（`stream`/`astream`），适配 SSE。
- **RetryPolicy / CachePolicy**：节点级可控重试与缓存。

---

## 3. 状态与线程设计

### 3.1 GraphState（保持 spec-07 结构，增加运行态字段）

```python
from typing import TypedDict, Optional, List

class GraphState(TypedDict):
    # 输入
    session_id: str
    user_input: str
    assets: List[dict]

    # Brief 输出
    product_doc: Optional[dict]
    pages: List[dict]
    data_model: Optional[dict]

    # Style 输出
    style_tokens: Optional[dict]

    # Component Registry 输出
    component_registry: Optional[dict]

    # Generate 输出
    page_schemas: List[dict]

    # Aesthetic Scorer 输出
    aesthetic_enabled: bool
    aesthetic_scores: Optional[dict]
    aesthetic_suggestions: List[dict]

    # Refine 输入/输出
    user_feedback: Optional[str]

    # Render 输出
    build_artifacts: Optional[dict]
    build_status: str

    # 运行态
    run_id: Optional[str]
    error: Optional[str]
```

### 3.2 thread_id 约定

- `thread_id` = `session_id`
- 任何图执行都必须传入：

```python
config = {"configurable": {"thread_id": session_id}}
```

这样可保证：
- 同一会话可恢复历史状态
- 不同会话互不污染

---

## 4. 图编排设计（LangGraph v1 语义）

### 4.1 Graph 构建（v1 推荐写法）

```python
from langgraph.graph import StateGraph, START, END
from langgraph.types import RetryPolicy

builder = StateGraph(GraphState)

# 节点注册
builder.add_node("brief", brief_node, retry_policy=RetryPolicy(max_attempts=2))
builder.add_node("style_extractor", style_extractor_node)
builder.add_node("component_registry", component_registry_node)
builder.add_node("generate", generate_node, retry_policy=RetryPolicy(max_attempts=2))
builder.add_node("aesthetic_scorer", aesthetic_scorer_node)
builder.add_node("refine_gate", refine_gate_node)
builder.add_node("refine", refine_node)
builder.add_node("render", render_node)

# 主路径
builder.add_edge(START, "brief")
builder.add_edge("brief", "style_extractor")
builder.add_edge("style_extractor", "component_registry")
builder.add_edge("component_registry", "generate")

# 条件分支（保持 spec-07 的 should_score / should_refine 语义）
builder.add_conditional_edges("generate", should_score_aesthetic, {
    "aesthetic": "aesthetic_scorer",
    "skip": "refine_gate",
})

builder.add_edge("aesthetic_scorer", "refine_gate")

builder.add_conditional_edges("refine_gate", should_refine, {
    "refine": "refine",
    "render": "render",
})

builder.add_edge("refine", "render")
builder.add_edge("render", END)
```

说明：
- **RetryPolicy** 取代 `retry_count` 自增逻辑。
- `refine_gate_node` 内部触发 `interrupt()`（详见 5.1）。

---

## 5. Human-in-the-loop（Refine 由 interrupt 驱动）

### 5.1 触发方式

当需要用户反馈时，在节点内调用 `interrupt()` 返回“等待输入”的信号：

```python
from langgraph.types import interrupt

async def refine_gate_node(state: GraphState):
    if not state.get("user_feedback"):
        return interrupt({
            "type": "need_user_feedback",
            "message": "请提供修改意见"
        })
    return state
```

### 5.2 恢复执行

收到前端反馈后，通过 `Command(resume=...)` 恢复：

```python
from langgraph.types import Command

resume_cmd = Command(resume={"user_feedback": feedback})
result = graph.invoke(resume_cmd, config={"configurable": {"thread_id": session_id}})
```

说明：
- `thread_id` 决定恢复的图状态。
- `interrupt()` 的 payload 会以 `__interrupt__` 形式出现在流式更新中，可直接映射为 SSE 事件。

---

## 6. 持久化设计（checkpointer）

### 6.1 必选原则

- **所有生产/本地环境必须启用 checkpointer**。
- 只有在“纯本地 demo 或测试”时允许无持久化编译。

### 6.2 方案选择

| 场景 | 方案 | 说明 |
|------|------|------|
| 开发 / 单元测试 | In-memory checkpointer | 轻量，不持久化 |
| 本地运行 | SQLite checkpointer | 和当前 SQLite 数据库对齐 |
| 生产 / 多实例 | Postgres checkpointer | 跨实例持久化、可扩展 |

（LangGraph v1 将各类 checkpointer 拆分为独立包，SQLite / Postgres 需额外安装。）

---

## 7. 流式输出与 SSE 对齐

### 7.1 流式执行

- 使用 `graph.stream` / `graph.astream`，`stream_mode=["updates"]`。
- 更新事件统一在后端转发为 SSE。

### 7.2 SSE 事件映射（扩展 spec-07）

新增事件：

```typescript
type SSEEventType =
  | 'brief_start' | 'brief_complete'
  | 'style_extracted'
  | 'registry_complete'
  | 'generate_start' | 'generate_progress' | 'generate_complete'
  | 'refine_waiting' | 'refine_start' | 'refine_complete'
  | 'build_start' | 'build_progress' | 'build_complete' | 'build_failed'
  | 'interrupt';
```

映射规则：
- `__interrupt__` → `interrupt` / `refine_waiting`
- 节点完成 → `*_complete`
- `runtime.stream_writer` 输出 → `*_progress`

---

## 8. 错误处理（重试与事务语义）

LangGraph v1 执行以 superstep 为单位：
- 同一 superstep 内并行节点失败会整体回滚更新。
- 成功节点结果会在 checkpointer 中保存，重试时不会重复执行已完成部分。

因此：
- 对 **IO/LLM 节点** 使用 `RetryPolicy(max_attempts=2~3)`。
- 对 **纯函数节点** 关闭重试或使用短 TTL 缓存。

---

## 9. API 对齐建议（最小改动）

- **/api/chat**
  - 初次调用：`graph.invoke(state, config)`
  - 继续调用：若携带 `resume` 字段，则使用 `Command(resume=...)`

- **/api/chat/stream**
  - 以 `graph.stream` 驱动 SSE
  - 监听 `__interrupt__` 并将 `refine_waiting` 发给前端

- **前端**
  - 收到 `refine_waiting` 时展示输入框
  - 提交后调用 `/api/chat` 继续执行

---

## 10. 迁移步骤（在 spec-07 基础上补充）

1. 升级 LangGraph 依赖到 v1（及对应 checkpointer 包）。
2. 用 `RetryPolicy` 替换现有 `retry_count` 逻辑。
3. 引入 `interrupt()` 与 `Command(resume=...)` 处理 Refine。
4. 将 SSE 事件源改为图 `stream` 输出。
5. 以 `thread_id=session_id` 统一所有会话恢复逻辑。

---

## 11. 验收标准（增量）

- 同一 `session_id` 可在中断后恢复执行，输出一致。
- 未开启 checkpointer 时，系统明确提示“不可恢复”。
- Refine 反馈可通过 `interrupt()` + `Command(resume)` 完成闭环。
- SSE `interrupt/refine_waiting` 事件能触发前端反馈输入。
